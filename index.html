<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>MGRS Calc</title>
  <link rel="manifest" href="manifest.json">
  <meta name="theme-color" content="#007aff">
  <link rel="apple-touch-icon" href="icon.png">
  <style>
    /* ========== カラーテーマ変数 ========== */
    :root {
      --bg-color: #f2f2f7;
      --card-bg: #ffffff;
      --text-color: #333333;
      --border-color: #cccccc;
      --input-bg: #ffffff;
      --input-text: #000000;
      --result-bg: #e5f0ff;
      --result-text: #004080;
      --map-bg: #ffffff;
      --map-grid: #e0e0e0;
      --map-text: #888888;
      --list-border: #eeeeee;
    }
    @media (prefers-color-scheme: dark) {
      :root {
        --bg-color: #000000;
        --card-bg: #1c1c1e;
        --text-color: #f5f5f5;
        --border-color: #444444;
        --input-bg: #2c2c2e;
        --input-text: #ffffff;
        --result-bg: #0a244d;
        --result-text: #66a3ff;
        --map-bg: #111111;
        --map-grid: #333333;
        --map-text: #aaaaaa;
        --list-border: #333333;
      }
    }

    body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif; background-color: var(--bg-color); color: var(--text-color); margin: 0; padding: 0; }
    header { background-color: #007aff; color: white; padding: 15px; text-align: center; font-size: 20px; font-weight: bold; }
    .container { padding: 15px; }
    
    select, input[type="text"], input[type="number"], textarea { background-color: var(--input-bg); color: var(--input-text); border: 1px solid var(--border-color); font-family: sans-serif; }
    select { width: 100%; padding: 10px; font-size: 16px; margin-bottom: 20px; border-radius: 8px; box-sizing: border-box; }
    textarea { width: 100%; box-sizing: border-box; padding: 12px; font-size: 14px; border-radius: 5px; resize: vertical; min-height: 120px; margin-bottom: 10px; font-family: monospace; }
    
    .card { background: var(--card-bg); padding: 15px; border-radius: 10px; box-shadow: 0 2px 5px rgba(0,0,0,0.2); margin-bottom: 15px; }
    .card h3 { margin-top: 0; font-size: 16px; color: var(--text-color); margin-bottom: 10px; }
    
    .input-group { display: flex; flex-direction: column; gap: 10px; margin-bottom: 15px; }
    .input-group input { width: 100%; box-sizing: border-box; padding: 12px; font-size: 16px; border-radius: 5px; }
    
    .route-row { display: flex; gap: 8px; margin-bottom: 10px; align-items: center; }
    .route-row input { flex: 1; min-width: 0; padding: 12px; font-size: 16px; border-radius: 5px; box-sizing: border-box; }
    .route-row button { width: auto; padding: 12px 15px; background-color: #ff3b30; margin-bottom: 0; border-radius: 5px; }
    
    button { width: 100%; padding: 15px; background-color: #007aff; color: white; border: none; border-radius: 8px; font-size: 16px; font-weight: bold; cursor: pointer; margin-bottom: 15px; box-sizing: border-box; }
    button:active { background-color: #005bb5; }
    button.btn-green { background-color: #34c759; }
    button.btn-gray { background-color: #8e8e93; }
    button.btn-red { background-color: #ff3b30; }
    button.btn-small { padding: 10px; font-size: 14px; margin-bottom: 10px;}
    
    .result { background: var(--result-bg); padding: 15px; border-radius: 8px; text-align: center; font-family: monospace; font-size: 18px; font-weight: bold; color: var(--result-text); }
    .hidden { display: none !important; }

    .color-select-row { display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px; padding: 0 5px; }
    .color-select-row span { font-size: 16px; font-weight: bold; color: var(--text-color); }
    .color-picker { width: 44px; height: 44px; padding: 0; border: none; border-radius: 5px; background: none; cursor: pointer; flex-shrink: 0; }
    
    .quick-save { display: flex; gap: 10px; align-items: center; justify-content: center; }
    .quick-save input[type="text"] { padding: 10px; border-radius: 5px; font-size: 16px; flex: 1; font-family: sans-serif; }
    .quick-save button { width: auto; margin: 0; padding: 10px 15px; background-color: #34c759; font-size: 14px; flex-shrink: 0; }

    .list-item { display: flex; justify-content: space-between; align-items: center; padding: 10px 0; border-bottom: 1px solid var(--list-border); transition: background-color 0.2s; background-color: var(--card-bg); }
    .list-item:last-child { border-bottom: none; }
    .list-item.dragging { background-color: var(--result-bg); opacity: 0.8; box-shadow: inset 0 0 8px rgba(0,0,0,0.1); }
    
    .drag-handle { padding: 10px 15px 10px 5px; font-size: 24px; color: #888; font-weight: bold; touch-action: none; cursor: grab; }
    .list-item div.content { font-size: 14px; flex: 1; margin-left: 5px; pointer-events: none; }
    .action-btns { display: flex; gap: 5px; margin-right: 5px; }
    .action-btns button { width: auto; padding: 8px 12px; margin: 0; font-size: 12px; border-radius: 5px; }

    .map-container { position: relative; width: 100%; }
    canvas { width: 100%; height: auto; aspect-ratio: 1; background-color: var(--map-bg); border: 1px solid var(--border-color); border-radius: 8px; touch-action: none; }
  </style>
</head>
<body>

<header>MGRS 計算アプリ</header>

<div class="container">
  <select id="menu" onchange="switchView()">
    <option value="func1">1. 座標対座標</option>
    <option value="func2">2. 極座標</option>
    <option value="func3">3. 前方交会法</option>
    <option value="func4">4. 後方交会法</option>
    <option value="func5">5. トラバース計算</option>
    <option value="func6">6. 座標の登録・一覧</option>
    <option value="func7">7. マップ (1km方眼)</option>
  </select>

  <div id="func1" class="view">
    <div class="card">
      <h3>現在地</h3>
      <div class="input-group"><input type="text" inputmode="numeric" id="f1_sx" placeholder="E座標"><input type="text" inputmode="numeric" id="f1_sy" placeholder="N座標"></div>
      <h3>目標地</h3>
      <div class="input-group"><input type="text" inputmode="numeric" id="f1_ex" placeholder="E座標"><input type="text" inputmode="numeric" id="f1_ey" placeholder="N座標"></div>
    </div>
    <button onclick="calcF1()">計算実行</button>
    <div id="res1" class="result hidden"></div>
  </div>

  <div id="func2" class="view hidden">
    <div class="card">
      <h3>現在地</h3>
      <div class="input-group"><input type="text" inputmode="numeric" id="f2_x" placeholder="E座標"><input type="text" inputmode="numeric" id="f2_y" placeholder="N座標"></div>
      <h3>目標への諸元</h3>
      <div class="input-group"><input type="number" id="f2_az" placeholder="方位角(mil)"><input type="number" id="f2_dist" placeholder="距離(m)"></div>
    </div>
    <button onclick="calcF2()">計算実行</button>
    <div id="res2" class="result hidden"></div>
  </div>

  <div id="func3" class="view hidden">
    <div class="card">
      <h3>観測点-A</h3>
      <div class="input-group"><input type="text" inputmode="numeric" id="f3_p1x" placeholder="E座標"><input type="text" inputmode="numeric" id="f3_p1y" placeholder="N座標"><input type="number" id="f3_az1" placeholder="目標への方位角 (mil)"></div>
    </div>
    <div class="card">
      <h3>観測点-B</h3>
      <div class="input-group"><input type="text" inputmode="numeric" id="f3_p2x" placeholder="E座標"><input type="text" inputmode="numeric" id="f3_p2y" placeholder="N座標"><input type="number" id="f3_az2" placeholder="目標への方位角 (mil)"></div>
    </div>
    <button onclick="calcF3()">計算実行</button>
    <div id="res3" class="result hidden"></div>
  </div>

  <div id="func4" class="view hidden">
    <div class="card">
      <p style="font-size:14px; color:var(--text-color); margin-top:0; opacity: 0.8;">未知の現在地から、既知の2点へ方位角を測定し、現在地を求めます。</p>
      <h3>既知点-A</h3>
      <div class="input-group"><input type="text" inputmode="numeric" id="f4_p1x" placeholder="E座標"><input type="text" inputmode="numeric" id="f4_p1y" placeholder="N座標"><input type="number" id="f4_az1" placeholder="Aへの測定方位角 (mil)"></div>
    </div>
    <div class="card">
      <h3>既知点-B</h3>
      <div class="input-group"><input type="text" inputmode="numeric" id="f4_p2x" placeholder="E座標"><input type="text" inputmode="numeric" id="f4_p2y" placeholder="N座標"><input type="number" id="f4_az2" placeholder="Bへの測定方位角 (mil)"></div>
    </div>
    <button onclick="calcF4()">計算実行</button>
    <div id="res4" class="result hidden"></div>
  </div>

  <div id="func5" class="view hidden">
    <div class="card">
      <h3>開始点</h3>
      <div class="input-group"><input type="text" inputmode="numeric" id="f5_x" placeholder="E座標"><input type="text" inputmode="numeric" id="f5_y" placeholder="N座標"></div>
      <h3>移動リスト</h3>
      <div id="routeList">
        <div class="route-row"><input type="number" class="r_az" placeholder="方位"><input type="number" class="r_dist" placeholder="距離"></div>
      </div>
      <button class="btn-green" onclick="addRouteRow()" style="margin-top:10px;">＋ 移動を追加</button>
    </div>
    <button onclick="calcF5()">計算実行</button>
    <div id="res5" class="result hidden"></div>
  </div>

  <div id="func6" class="view hidden">
    <div class="card">
      <h3>テキストで一括入出力</h3>
      <p style="font-size:12px; margin-top:0; opacity:0.8;">【書式】名称 E座標 N座標 色（スペース区切り）<br>※同名の座標が存在する場合は自動で上書きされます。</p>
      <textarea id="io_text" placeholder="ここにテキストを貼り付けて読み込むか、下のボタンで現在のデータを書き出します。"></textarea>
      <div style="display:flex; gap:10px;">
        <button class="btn-green btn-small" onclick="importPoints()" style="margin:0; flex:1;">↓ 読み込み</button>
        <button class="btn-gray btn-small" onclick="exportPoints()" style="margin:0; flex:1;">↑ 書き出し</button>
        <button class="btn-red btn-small" onclick="deleteAllPoints()" style="margin:0; flex:1;">一括削除</button>
      </div>
    </div>

    <div id="edit_card" class="card">
      <h3 id="edit_title">座標を手動登録</h3>
      <div class="color-select-row">
        <span>マップ表示色</span>
        <input type="color" id="f6_color" class="color-picker">
      </div>
      <div class="input-group">
        <input type="text" id="f6_name" placeholder="名称 (例: 観測所A)">
        <input type="text" inputmode="numeric" id="f6_x" placeholder="E座標">
        <input type="text" inputmode="numeric" id="f6_y" placeholder="N座標">
      </div>
      <div style="display:flex; gap:10px;">
        <button id="btn_manual_save" class="btn-green" onclick="savePointManual()" style="margin-bottom:0;">登録</button>
        <button id="btn_manual_cancel" class="btn-gray hidden" onclick="cancelEdit()" style="margin-bottom:0; width:40%;">キャンセル</button>
      </div>
    </div>

    <div class="card">
      <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:10px;">
        <h3 style="margin:0;">登録済み座標</h3>
        <select id="sort_select" style="width:auto; padding:5px 10px; font-size:14px; margin:0; border-radius:5px;" onchange="applySort()">
          <option value="manual">手動(≡)</option>
          <option value="name_asc">名前順</option>
          <option value="e_asc">E座標(西→東)</option>
          <option value="n_asc">N座標(南→北)</option>
        </select>
      </div>
      <div id="savedList"></div>
    </div>
  </div>

  <div id="func7" class="view hidden">
    <div class="card">
      <h3>マップ (1km方眼)</h3>
      <p style="font-size:12px; margin-top:0; opacity:0.7;">※1本指で移動、2本指で拡大縮小</p>
      <div class="map-container">
        <canvas id="mapCanvas" width="400" height="400"></canvas>
      </div>
      <button class="btn-gray btn-small" onclick="resetMapView()" style="margin-top:10px;">視点をリセット</button>
      
      <h3 style="margin-top: 20px;">登録座標から諸元計算</h3>
      <div class="input-group">
        <select id="map_start"></select>
        <select id="map_end"></select>
      </div>
      <button onclick="calcMap()">方位角・距離を計算</button>
      <div id="resMap" class="result hidden"></div>
    </div>
  </div>
</div>

<script>
  if ('serviceWorker' in navigator) {
    navigator.serviceWorker.register('sw.js').catch(err => console.log('SW registration failed:', err));
  }

  const MILS_CIRCLE = 6400.0;
  let savedPoints = JSON.parse(localStorage.getItem('mgrsPoints') || '[]');
  let lastColor = localStorage.getItem('mgrsLastColor') || '#ff3b30';
  let editingId = null; // ★編集モード用のフラグ

  const parseCoord = (val) => {
    if (val === "" || val === null || val === undefined) return null;
    let s = String(val).trim().substring(0, 5).padEnd(5, '0');
    return Number(s);
  };

  const pad5 = (num) => {
    let n = Math.round(num);
    n = ((n % 100000) + 100000) % 100000;
    return String(n).padStart(5, '0');
  };
  const pad4 = (num) => String(Math.round(num)).padStart(4, '0');

  function parseColorStr(c) {
    if (!c) return lastColor;
    let m = c.trim().toLowerCase();
    const cmap = {
      '赤': '#ff3b30', 'red': '#ff3b30', '青': '#007aff', 'blue': '#007aff',
      '緑': '#34c759', 'green': '#34c759', '黄': '#ffcc00', 'yellow': '#ffcc00',
      '黒': '#000000', 'black': '#000000', '白': '#ffffff', 'white': '#ffffff',
      '紫': '#af52de', 'purple': '#af52de', '橙': '#ff9500', 'orange': '#ff9500'
    };
    if (cmap[m]) return cmap[m];
    if (m.startsWith('#') && (m.length === 4 || m.length === 7)) return m;
    return lastColor;
  }

  function syncColorPickers(newColor) {
    if(newColor) { lastColor = newColor; localStorage.setItem('mgrsLastColor', lastColor); }
    document.querySelectorAll('.color-picker').forEach(el => { el.value = lastColor; });
  }

  function switchView() {
    document.querySelectorAll('.view').forEach(v => v.classList.add('hidden'));
    let selected = document.getElementById('menu').value;
    document.getElementById(selected).classList.remove('hidden');
    syncColorPickers();
    if (selected === 'func6') updateSavedList();
    if (selected === 'func7') { updateMapDropdowns(); drawMap(null, null, true); }
  }

  function calcData(sx, sy, ex, ey) {
    let dx = ex - sx; let dy = ey - sy;
    if (dx < -50000) dx += 100000; else if (dx > 50000) dx -= 100000;
    if (dy < -50000) dy += 100000; else if (dy > 50000) dy -= 100000;
    let dist = Math.sqrt(dx*dx + dy*dy);
    let rad = Math.atan2(dx, dy);
    let mil = rad * (MILS_CIRCLE / (2 * Math.PI));
    if (mil < 0) mil += MILS_CIRCLE;
    return { mil: mil, dist: dist };
  }

  // クイックセーブ (同名なら自動上書き)
  function getSaveUI(inputId, x, y) {
    return `<div style="margin-top: 20px; border-top: 1px dashed var(--border-color); padding-top: 15px;">
              <div class="color-select-row" style="margin-bottom:10px;">
                <span style="font-size: 14px;">マップ表示色</span>
                <input type="color" id="${inputId}_color" class="color-picker" onchange="syncColorPickers(this.value)">
              </div>
              <div class="quick-save">
                <input type="text" id="${inputId}" placeholder="名称">
                <button onclick="quickSave('${inputId}', ${x}, ${y})">登録</button>
              </div>
            </div>`;
  }

  function quickSave(inputId, x, y) {
    let name = document.getElementById(inputId).value;
    let colorInput = document.getElementById(inputId + '_color');
    let color = colorInput ? colorInput.value : lastColor;
    if (!name) { alert("名称を入力してください"); return; }
    
    syncColorPickers(color);
    
    // 同名なら上書き
    let existing = savedPoints.find(p => p.name === name);
    if(existing) {
        existing.e = Number(x); existing.n = Number(y); existing.color = color;
        alert(name + " を上書き登録しました！");
    } else {
        savedPoints.push({ id: Date.now(), name: name, e: Number(x), n: Number(y), color: color });
        alert(name + " を登録しました！");
    }
    
    localStorage.setItem('mgrsPoints', JSON.stringify(savedPoints));
    document.getElementById(inputId).value = "";
    updateSavedList(); updateMapDropdowns();
  }

  // 機能1〜5の計算ロジック
  function calcF1() {
    let sx = parseCoord(document.getElementById('f1_sx').value); let sy = parseCoord(document.getElementById('f1_sy').value);
    let ex = parseCoord(document.getElementById('f1_ex').value); let ey = parseCoord(document.getElementById('f1_ey').value);
    if(sx===null || sy===null || ex===null || ey===null) return;
    let r = calcData(sx, sy, ex, ey);
    let res = document.getElementById('res1');
    res.innerHTML = `方位角: ${pad4(r.mil)}<br>距離: ${Math.round(r.dist)} m`;
    res.classList.remove('hidden');
  }

  function calcF2() {
    let x = parseCoord(document.getElementById('f2_x').value); let y = parseCoord(document.getElementById('f2_y').value);
    let az = Number(document.getElementById('f2_az').value); let dist = Number(document.getElementById('f2_dist').value);
    if(x===null || y===null) return;
    let rad = az * (2 * Math.PI / MILS_CIRCLE);
    let targetX = x + dist * Math.sin(rad); let targetY = y + dist * Math.cos(rad);
    let res = document.getElementById('res2');
    res.innerHTML = `目標座標<br>E: ${pad5(targetX)}  N: ${pad5(targetY)}` + getSaveUI('qname_f2', targetX, targetY);
    res.classList.remove('hidden'); syncColorPickers();
  }

  function calcF3() {
    let p1x = parseCoord(document.getElementById('f3_p1x').value); let p1y = parseCoord(document.getElementById('f3_p1y').value); let az1 = Number(document.getElementById('f3_az1').value);
    let p2x = parseCoord(document.getElementById('f3_p2x').value); let p2y = parseCoord(document.getElementById('f3_p2y').value); let az2 = Number(document.getElementById('f3_az2').value);
    if(p1x===null || p2x===null) return;
    let rad1 = az1 * (2 * Math.PI / MILS_CIRCLE); let rad2 = az2 * (2 * Math.PI / MILS_CIRCLE);
    let tan1 = Math.tan(Math.PI/2 - rad1); let tan2 = Math.tan(Math.PI/2 - rad2);
    let res = document.getElementById('res3');
    if (Math.abs(tan1 - tan2) < 0.0001) res.innerHTML = '<span style="color:red">交点なし (平行等)</span>';
    else {
      let intX = (tan1 * p1x - tan2 * p2x + p2y - p1y) / (tan1 - tan2); let intY = tan1 * (intX - p1x) + p1y;
      res.innerHTML = `交点座標<br>E: ${pad5(intX)}  N: ${pad5(intY)}` + getSaveUI('qname_f3', intX, intY);
    }
    res.classList.remove('hidden'); syncColorPickers();
  }

  function calcF4() {
    let p1x = parseCoord(document.getElementById('f4_p1x').value); let p1y = parseCoord(document.getElementById('f4_p1y').value); let az1 = Number(document.getElementById('f4_az1').value);
    let p2x = parseCoord(document.getElementById('f4_p2x').value); let p2y = parseCoord(document.getElementById('f4_p2y').value); let az2 = Number(document.getElementById('f4_az2').value);
    if(p1x===null || p2x===null) return;
    let backAz1 = (az1 + 3200) % 6400; let backAz2 = (az2 + 3200) % 6400;
    let rad1 = backAz1 * (2 * Math.PI / MILS_CIRCLE); let rad2 = backAz2 * (2 * Math.PI / MILS_CIRCLE);
    let tan1 = Math.tan(Math.PI/2 - rad1); let tan2 = Math.tan(Math.PI/2 - rad2);
    let res = document.getElementById('res4');
    if (Math.abs(tan1 - tan2) < 0.0001) res.innerHTML = '<span style="color:red">交点なし (平行等)</span>';
    else {
      let intX = (tan1 * p1x - tan2 * p2x + p2y - p1y) / (tan1 - tan2); let intY = tan1 * (intX - p1x) + p1y;
      res.innerHTML = `現在地座標<br>E: ${pad5(intX)}  N: ${pad5(intY)}` + getSaveUI('qname_f4', intX, intY);
    }
    res.classList.remove('hidden'); syncColorPickers();
  }

  function addRouteRow() {
    let row = document.createElement('div'); row.className = 'route-row';
    row.innerHTML = `<input type="number" class="r_az" placeholder="方位"><input type="number" class="r_dist" placeholder="距離"><button onclick="this.parentElement.remove()">×</button>`;
    document.getElementById('routeList').appendChild(row);
  }

  const getCompactSaveUI = (id, label, x, y) => {
    return `<div style="margin-bottom: 20px; padding-bottom: 15px; border-bottom: 1px dashed var(--border-color); text-align: left;">
              <div style="font-family: monospace; font-size: 16px; margin-bottom: 8px;">${label}: E:${pad5(x)} N:${pad5(y)}</div>
              <div class="quick-save" style="margin-top: 5px;">
                <input type="text" id="${id}" placeholder="${label}の名称">
                <button onclick="quickSaveTraverse('${id}', ${x}, ${y})">登録</button>
              </div>
            </div>`;
  };

  function quickSaveTraverse(inputId, x, y) {
    let name = document.getElementById(inputId).value;
    let colorInput = document.getElementById('f5_color');
    let color = colorInput ? colorInput.value : lastColor;
    if (!name) { alert("名称を入力してください"); return; }
    syncColorPickers(color);
    
    let existing = savedPoints.find(p => p.name === name);
    if(existing) {
        existing.e = Number(x); existing.n = Number(y); existing.color = color;
        alert(name + " を上書き登録しました！");
    } else {
        savedPoints.push({ id: Date.now(), name: name, e: Number(x), n: Number(y), color: color });
        alert(name + " を登録しました！");
    }
    
    localStorage.setItem('mgrsPoints', JSON.stringify(savedPoints));
    document.getElementById(inputId).value = "";
    updateSavedList(); updateMapDropdowns();
  }

  function calcF5() {
    let cx = parseCoord(document.getElementById('f5_x').value); let cy = parseCoord(document.getElementById('f5_y').value);
    if(cx===null || cy===null) return;
    let azInputs = document.querySelectorAll('.r_az'); let distInputs = document.querySelectorAll('.r_dist');
    let html = `<div class="color-select-row" style="margin-bottom:15px; padding-bottom: 10px;">
                  <span style="font-size: 14px;">一括マップ表示色</span>
                  <input type="color" id="f5_color" class="color-picker" onchange="syncColorPickers(this.value)">
                </div>`;
    html += getCompactSaveUI('qname_f5_0', '始点', cx, cy);
    for (let i = 0; i < azInputs.length; i++) {
      let az = Number(azInputs[i].value); let dist = Number(distInputs[i].value);
      if (azInputs[i].value === "" || distInputs[i].value === "") continue;
      let rad = az * (2 * Math.PI / MILS_CIRCLE);
      cx = cx + dist * Math.sin(rad); cy = cy + dist * Math.cos(rad);
      html += getCompactSaveUI(`qname_f5_${i+1}`, `経由点${i+1}`, cx, cy);
    }
    let res = document.getElementById('res5'); res.innerHTML = html; res.classList.remove('hidden');
    syncColorPickers();
  }

  // ★テキスト一括入出力 (同名上書き対応)
  function importPoints() {
    let text = document.getElementById('io_text').value;
    if (!text.trim()) { alert("テキストを入力してください。"); return; }
    let lines = text.split('\n');
    let addedCount = 0; let updatedCount = 0;
    
    for (let line of lines) {
       let parts = line.trim().split(/[\s\t]+/);
       if (parts.length >= 3) {
          let name = parts[0]; let e = parseCoord(parts[1]); let n = parseCoord(parts[2]);
          if (e !== null && n !== null) {
             let color = parts.length >= 4 ? parseColorStr(parts[3]) : lastColor;
             let existing = savedPoints.find(p => p.name === name);
             if (existing) {
                 existing.e = e; existing.n = n; existing.color = color;
                 updatedCount++;
             } else {
                 savedPoints.push({ id: Date.now() + Math.floor(Math.random()*1000), name: name, e: e, n: n, color: color });
                 addedCount++;
             }
          }
       }
    }
    if (addedCount > 0 || updatedCount > 0) {
       localStorage.setItem('mgrsPoints', JSON.stringify(savedPoints));
       updateSavedList(); drawMap(null, null, true);
       alert(`${addedCount}件を新規追加、${updatedCount}件を上書きしました！`);
       document.getElementById('io_text').value = "";
    } else { alert("読み込める座標がありませんでした。\n【書式】名称 E座標 N座標 色"); }
  }

  function exportPoints() {
    if (savedPoints.length === 0) { alert("書き出すデータがありません。"); return; }
    let out = savedPoints.map(p => `${p.name} ${pad5(p.e)} ${pad5(p.n)} ${p.color || '#ff3b30'}`).join('\n');
    document.getElementById('io_text').value = out;
  }

  // ★全件削除アラート
  function deleteAllPoints() {
    if (savedPoints.length === 0) return;
    if (confirm("本当にすべての登録座標を削除しますか？\n（この操作は元に戻せません）")) {
       savedPoints = [];
       localStorage.setItem('mgrsPoints', JSON.stringify(savedPoints));
       updateSavedList(); drawMap(null, null, true);
       alert("すべての座標を削除しました。");
    }
  }

  // ★編集と手動登録ロジック
  document.getElementById('f6_color').addEventListener('change', function(e) { syncColorPickers(e.target.value); });

  function editPoint(id) {
    let p = savedPoints.find(p => p.id === id);
    if (!p) return;
    editingId = id;
    document.getElementById('edit_title').innerText = "座標を編集する";
    document.getElementById('f6_name').value = p.name;
    document.getElementById('f6_x').value = pad5(p.e);
    document.getElementById('f6_y').value = pad5(p.n);
    document.getElementById('f6_color').value = p.color || lastColor;
    
    document.getElementById('btn_manual_save').innerText = "更新";
    document.getElementById('btn_manual_cancel').classList.remove('hidden');
    
    document.getElementById('edit_card').scrollIntoView({ behavior: 'smooth' });
  }

  function cancelEdit() {
    editingId = null;
    document.getElementById('edit_title').innerText = "座標を手動登録";
    document.getElementById('f6_name').value = "";
    document.getElementById('f6_x').value = "";
    document.getElementById('f6_y').value = "";
    document.getElementById('btn_manual_save').innerText = "登録";
    document.getElementById('btn_manual_cancel').classList.add('hidden');
  }

  function savePointManual() {
    let name = document.getElementById('f6_name').value;
    let x = parseCoord(document.getElementById('f6_x').value); let y = parseCoord(document.getElementById('f6_y').value);
    let color = document.getElementById('f6_color').value;
    
    if (!name || x === null || y === null) { alert("名称と座標を入力してください"); return; }
    
    if (editingId !== null) {
        // 編集モード
        let conflict = savedPoints.find(p => p.name === name && p.id !== editingId);
        if (conflict) {
            // 名前を変更して別の既存名と被った場合は上書き統合
            conflict.e = x; conflict.n = y; conflict.color = color;
            savedPoints = savedPoints.filter(p => p.id !== editingId);
        } else {
            let p = savedPoints.find(p => p.id === editingId);
            if (p) { p.name = name; p.e = x; p.n = y; p.color = color; }
        }
        alert(name + " を更新しました！");
    } else {
        // 新規登録モード (同名は上書き)
        let existing = savedPoints.find(p => p.name === name);
        if (existing) {
            existing.e = x; existing.n = y; existing.color = color;
            alert(name + " を上書き登録しました！");
        } else {
            savedPoints.push({ id: Date.now(), name: name, e: x, n: y, color: color });
        }
    }
    
    cancelEdit();
    localStorage.setItem('mgrsPoints', JSON.stringify(savedPoints));
    updateSavedList(); drawMap(null, null, true);
  }

  function deletePoint(id) {
    savedPoints = savedPoints.filter(p => p.id !== id);
    localStorage.setItem('mgrsPoints', JSON.stringify(savedPoints));
    updateSavedList(); drawMap(null, null, true);
  }

  // ★自動ソート処理
  function applySort() {
    let mode = document.getElementById('sort_select').value;
    if (mode === 'manual') return; // 手動はそのまま（何もしない）
    
    if (mode === 'name_asc') {
       savedPoints.sort((a, b) => a.name.localeCompare(b.name, 'ja'));
    } else if (mode === 'e_asc') {
       savedPoints.sort((a, b) => a.e - b.e);
    } else if (mode === 'n_asc') {
       savedPoints.sort((a, b) => a.n - b.n);
    }
    
    localStorage.setItem('mgrsPoints', JSON.stringify(savedPoints));
    updateSavedList();
  }

  function updateSavedList() {
    let html = "";
    if (savedPoints.length === 0) html = "<p style='text-align:center; color:#888;'>登録データがありません</p>";
    savedPoints.forEach((p) => {
      let pColor = p.color || '#ff3b30';
      html += `<div class="list-item" data-id="${p.id}">
                 <div class="drag-handle">≡</div>
                 <div class="content">
                   <strong><span style="display:inline-block; width:12px; height:12px; background:${pColor}; border-radius:50%; margin-right:5px; vertical-align:middle;"></span>${p.name}</strong><br>E: ${pad5(p.e)} / N: ${pad5(p.n)}
                 </div>
                 <div class="action-btns">
                   <button class="btn-gray" onclick="editPoint(${p.id})">編集</button>
                   <button class="btn-red" onclick="deletePoint(${p.id})">削除</button>
                 </div>
               </div>`;
    });
    document.getElementById('savedList').innerHTML = html;
  }

  // ドラッグ＆ドロップ
  const listContainer = document.getElementById('savedList');
  let dragEl = null;

  listContainer.addEventListener('touchstart', function(e) {
    const handle = e.target.closest('.drag-handle');
    if (!handle) return;
    e.preventDefault(); 
    dragEl = handle.closest('.list-item');
    dragEl.classList.add('dragging');
  }, {passive: false});

  listContainer.addEventListener('touchmove', function(e) {
    if (!dragEl) return;
    e.preventDefault();
    const touch = e.touches[0];
    const target = document.elementFromPoint(touch.clientX, touch.clientY);
    if (!target) return;
    const targetItem = target.closest('.list-item');
    if (targetItem && targetItem !== dragEl) {
      const rect = targetItem.getBoundingClientRect();
      const isNext = (touch.clientY - rect.top) / (rect.bottom - rect.top) > 0.5;
      targetItem.parentNode.insertBefore(dragEl, isNext ? targetItem.nextSibling : targetItem);
    }
  }, {passive: false});

  listContainer.addEventListener('touchend', function(e) {
    if (!dragEl) return;
    dragEl.classList.remove('dragging');
    dragEl = null;
    const items = document.querySelectorAll('#savedList .list-item');
    let newArray = [];
    items.forEach(item => {
      const id = parseInt(item.getAttribute('data-id'));
      const point = savedPoints.find(p => p.id === id);
      if(point) newArray.push(point);
    });
    savedPoints = newArray;
    localStorage.setItem('mgrsPoints', JSON.stringify(savedPoints));
    
    // スライド操作をしたので、ソートメニューを「手動」に戻す
    document.getElementById('sort_select').value = 'manual';
    
    updateMapDropdowns();
  });

  // ========== マップ描画 ==========
  let mapState = { x: 0, y: 0, scale: 1, baseScale: 1, refE: 0, refN: 0, minDx: 0, maxDx: 0, minDy: 0, maxDy: 0, padding: 30 };
  let currentP1 = null; let currentP2 = null;

  function updateMapDropdowns() {
    let start = document.getElementById('map_start'); let end = document.getElementById('map_end');
    let html = '<option value="">--- 選択してください ---</option>';
    savedPoints.forEach(p => { html += `<option value="${p.id}">${p.name}</option>`; });
    start.innerHTML = html; end.innerHTML = html;
  }

  function calcMap() {
    let sId = document.getElementById('map_start').value; let eId = document.getElementById('map_end').value;
    if (!sId || !eId) return;
    currentP1 = savedPoints.find(p => p.id == sId); currentP2 = savedPoints.find(p => p.id == eId);
    let r = calcData(currentP1.e, currentP1.n, currentP2.e, currentP2.n);
    let res = document.getElementById('resMap');
    res.innerHTML = `【${currentP1.name} → ${currentP2.name}】<br>方位角: ${pad4(r.mil)}<br>距離: ${Math.round(r.dist)} m`;
    res.classList.remove('hidden');
    drawMap(currentP1, currentP2, false);
  }

  function resetMapView() { drawMap(currentP1, currentP2, true); }

  function drawMap(highlightP1 = null, highlightP2 = null, resetView = false) {
    let canvas = document.getElementById('mapCanvas'); let ctx = canvas.getContext('2d');
    let w = canvas.width, h = canvas.height;
    
    const style = getComputedStyle(document.body);
    const cBg = style.getPropertyValue('--map-bg').trim() || "#fff";
    const cGrid = style.getPropertyValue('--map-grid').trim() || "#e0e0e0";
    const cText = style.getPropertyValue('--map-text').trim() || "#888";
    const cMainText = style.getPropertyValue('--text-color').trim() || "#333";

    ctx.fillStyle = cBg; ctx.fillRect(0, 0, w, h);

    if (savedPoints.length === 0) {
      ctx.fillStyle = cText; ctx.font = "16px sans-serif"; ctx.textAlign = "center";
      ctx.fillText("座標が登録されていません", w/2, h/2); return;
    }

    if (resetView) {
      mapState.refE = savedPoints[0].e;
      mapState.refN = savedPoints[0].n;
      let minDx = 0, maxDx = 0, minDy = 0, maxDy = 0;
      savedPoints.forEach(p => {
        let dx = p.e - mapState.refE; if (dx > 50000) dx -= 100000; else if (dx < -50000) dx += 100000;
        let dy = p.n - mapState.refN; if (dy > 50000) dy -= 100000; else if (dy < -50000) dy += 100000;
        if (dx < minDx) minDx = dx; if (dx > maxDx) maxDx = dx;
        if (dy < minDy) minDy = dy; if (dy > maxDy) maxDy = dy;
      });
      if (maxDx - minDx < 2000) { let mid = (maxDx + minDx)/2; minDx = mid - 1000; maxDx = mid + 1000; }
      if (maxDy - minDy < 2000) { let mid = (maxDy + minDy)/2; minDy = mid - 1000; maxDy = mid + 1000; }
      mapState.minDx = minDx; mapState.maxDx = maxDx; mapState.minDy = minDy; mapState.maxDy = maxDy;
      mapState.baseScale = Math.min((w - mapState.padding*2) / (maxDx - minDx), (h - mapState.padding*2) / (maxDy - minDy));
      mapState.x = 0; mapState.y = 0; mapState.scale = 1;
    }

    let getX = (e) => { let dx = e - mapState.refE; if (dx > 50000) dx -= 100000; else if (dx < -50000) dx += 100000; return (mapState.padding + (dx - mapState.minDx) * mapState.baseScale) * mapState.scale + mapState.x; };
    let getY = (n) => { let dy = n - mapState.refN; if (dy > 50000) dy -= 100000; else if (dy < -50000) dy += 100000; return (h - mapState.padding - (dy - mapState.minDy) * mapState.baseScale) * mapState.scale + mapState.y; };
    let getX_real = (e_real) => { let dx = e_real - mapState.refE; return (mapState.padding + (dx - mapState.minDx) * mapState.baseScale) * mapState.scale + mapState.x; };
    let getY_real = (n_real) => { let dy = n_real - mapState.refN; return (h - mapState.padding - (dy - mapState.minDy) * mapState.baseScale) * mapState.scale + mapState.y; };
    let screenToDx = (X) => mapState.minDx + ((X - mapState.x) / mapState.scale - mapState.padding) / mapState.baseScale;
    let screenToDy = (Y) => mapState.minDy + ((h - mapState.padding - (Y - mapState.y) / mapState.scale)) / mapState.baseScale;
    
    let startDx = screenToDx(0) - 1000; let endDx = screenToDx(w) + 1000; let endDy = screenToDy(0) + 1000; let startDy = screenToDy(h) - 1000; 
    if(startDy > endDy) { let tmp = startDy; startDy = endDy; endDy = tmp; }
    if(startDx > endDx) { let tmp = startDx; startDx = endDx; endDx = tmp; }

    let startE_real = Math.floor((mapState.refE + startDx) / 1000) * 1000; let endE_real = Math.ceil((mapState.refE + endDx) / 1000) * 1000;
    let startN_real = Math.floor((mapState.refN + startDy) / 1000) * 1000; let endN_real = Math.ceil((mapState.refN + endDy) / 1000) * 1000;

    ctx.strokeStyle = cGrid; ctx.lineWidth = 1; ctx.font = "10px sans-serif"; ctx.fillStyle = cText;
    
    ctx.textAlign = "center";
    for(let e = startE_real; e <= endE_real; e += 1000) { let x = getX_real(e); if(x > -50 && x < w + 50) { ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, h); ctx.stroke(); ctx.fillText(pad5(e).substring(0,2), x, h - 5); } }
    ctx.textAlign = "left";
    for(let n = startN_real; n <= endN_real; n += 1000) { let y = getY_real(n); if(y > -50 && y < h + 50) { ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(w, y); ctx.stroke(); ctx.fillText(pad5(n).substring(0,2), 5, y + 3); } }

    if (highlightP1 && highlightP2) { ctx.strokeStyle = 'rgba(0, 122, 255, 0.7)'; ctx.lineWidth = 3; ctx.beginPath(); ctx.moveTo(getX(highlightP1.e), getY(highlightP1.n)); ctx.lineTo(getX(highlightP2.e), getY(highlightP2.n)); ctx.stroke(); }

    savedPoints.forEach(p => {
      let x = getX(p.e), y = getY(p.n); let pinColor = p.color || '#ff3b30';
      if(x > -20 && x < w + 20 && y > -20 && y < h + 20) {
        ctx.beginPath(); ctx.arc(x, y, 6, 0, Math.PI*2); ctx.fillStyle = pinColor; ctx.fill();
        ctx.strokeStyle = cBg; ctx.lineWidth = 2; ctx.stroke(); ctx.fillStyle = cMainText; ctx.font = "bold 12px sans-serif";
        ctx.fillText(p.name, x + 10, y + 4);
      }
    });
  }

  const canvas = document.getElementById('mapCanvas');
  let isDragging = false; let startPan = { x: 0, y: 0 }; let initialPinchDist = null;

  canvas.addEventListener('touchstart', (e) => { e.preventDefault(); if (e.touches.length === 1) { isDragging = true; startPan = { x: e.touches[0].clientX - mapState.x, y: e.touches[0].clientY - mapState.y }; } else if (e.touches.length === 2) { isDragging = false; initialPinchDist = Math.hypot(e.touches[0].clientX - e.touches[1].clientX, e.touches[0].clientY - e.touches[1].clientY); } }, { passive: false });
  canvas.addEventListener('touchmove', (e) => {
    e.preventDefault();
    if (e.touches.length === 1 && isDragging) { mapState.x = e.touches[0].clientX - startPan.x; mapState.y = e.touches[0].clientY - startPan.y; requestAnimationFrame(() => drawMap(currentP1, currentP2, false)); }
    else if (e.touches.length === 2 && initialPinchDist) {
      const newDist = Math.hypot(e.touches[0].clientX - e.touches[1].clientX, e.touches[0].clientY - e.touches[1].clientY);
      const centerX = (e.touches[0].clientX + e.touches[1].clientX) / 2; const centerY = (e.touches[0].clientY + e.touches[1].clientY) / 2;
      const rect = canvas.getBoundingClientRect(); const canvasCenterX = centerX - rect.left; const canvasCenterY = centerY - rect.top;
      const scaleFactor = newDist / initialPinchDist;
      mapState.x = canvasCenterX - (canvasCenterX - mapState.x) * scaleFactor; mapState.y = canvasCenterY - (canvasCenterY - mapState.y) * scaleFactor;
      mapState.scale *= scaleFactor; requestAnimationFrame(() => drawMap(currentP1, currentP2, false)); initialPinchDist = newDist;
    }
  }, { passive: false });
  canvas.addEventListener('touchend', (e) => { e.preventDefault(); if (e.touches.length < 2) initialPinchDist = null; if (e.touches.length === 0) isDragging = false; });

  // 初期化実行
  updateSavedList(); syncColorPickers();
</script>
</body>
</html>
